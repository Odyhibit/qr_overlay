<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom QR Code Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background-color: #f9fafb;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .sidebar {
            width: 320px;
            background-color: white;
            padding: 24px;
            overflow-y: auto;
            border-right: 1px solid #e5e7eb;
        }
        .preview-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 32px;
        }
        .preview-container {
            position: relative;
        }
        h1 {
            font-size: 24px;
            font-weight: bold;
            margin: 0 0 24px 0;
        }
        .section {
            margin-bottom: 24px;
        }
        label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
        }
        label.small {
            font-size: 12px;
            color: #4b5563;
            margin-bottom: 4px;
        }
        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            width: 100%;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            font-weight: 500;
        }
        button.primary {
            background-color: #2563eb;
            color: white;
            margin-top: 8px;
        }
        button.primary:hover {
            background-color: #1d4ed8;
        }
        button.secondary {
            background-color: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
        }
        button.secondary:hover {
            background-color: #e5e7eb;
        }
        button.success {
            background-color: #16a34a;
            color: white;
            padding: 12px 16px;
        }
        button.success:hover {
            background-color: #15803d;
        }
        .file-input-label {
            display: inline-block;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            text-align: center;
            transition: all 0.2s;
            border: none;
            width: 100%;
        }
        .file-input-label.primary {
            background-color: #2563eb;
            color: white;
        }
        .file-input-label.primary:hover {
            background-color: #1d4ed8;
        }
        .file-input-label.secondary {
            background-color: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
        }
        .file-input-label.secondary:hover {
            background-color: #e5e7eb;
        }
        .divider {
            text-align: center;
            font-size: 14px;
            color: #6b7280;
            margin: 12px 0;
        }
        .hidden {
            display: none;
        }
        .color-control {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        input[type="color"] {
            width: 64px;
            height: 40px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
        }
        .palette-color {
            width: 100%;
            height: 50px;
            cursor: pointer;
            border: 2px solid #d1d5db;
            transition: all 0.2s;
        }
        .palette-color:hover {
            border-color: #2563eb;
        }
        .palette-color.selected {
            border: 3px solid #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: #e5e7eb;
            height: 6px;
            border-radius: 3px;
            outline: none;
            flex: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            border: none;
        }
        .range-full {
            width: 100%;
        }
        .label-text {
            font-size: 14px;
        }
        canvas {
            border: 2px solid #d1d5db;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            background-color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Controls -->
        <div class="sidebar">
            <h1>QR Code Generator</h1>

            <!-- Setup Panel (Collapsible) -->
            <div class="section">
                <label style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; font-weight: 600; font-size: 16px;" id="setupToggle">
                    <span>‚öôÔ∏è Setup</span>
                    <span id="setupArrow" style="transition: transform 0.2s;">‚ñº</span>
                </label>
                <div id="setupPanel" style="margin-top: 12px;">
                    <!-- QR Input -->
                    <div class="section" style="padding: 0; margin-bottom: 16px;">
                        <label>QR Code Input</label>
                        <div>
                            <div>
                                <input
                                    type="text"
                                    id="qrText"
                                    value="https://example.com"
                                    placeholder="Enter URL or text"
                                />
                                <div style="margin-top: 8px;">
                                    <label style="font-size: 12px; font-weight: 500; color: #6b7280; display: block; margin-bottom: 4px;">Error Correction Level</label>
                                    <select id="eccLevel" class="range-full" style="padding: 8px; border-radius: 6px; border: 1px solid #d1d5db; background: white; font-size: 14px;">
                                        <option value="L">L - Low (7%)</option>
                                        <option value="M">M - Medium (15%)</option>
                                        <option value="Q">Q - Quartile (25%)</option>
                                        <option value="H" selected>H - High (30%)</option>
                                    </select>
                                    <div style="font-size: 11px; color: #6b7280; margin-top: 4px;">Higher = better scanning with logo overlay</div>
                                </div>
                                <button
                                    id="generateBtn"
                                    class="primary"
                                    style="margin-top: 8px;"
                                >
                                    Generate QR Code
                                </button>
                            </div>
                            <div class="divider">OR</div>
                            <div>
                                <label class="file-input-label secondary">
                                    <span>üì§ Upload QR Code</span>
                                    <input type="file" id="qrUpload" accept="image/*" class="hidden" />
                                </label>
                                <select id="qrSize" class="hidden" style="margin-top: 8px;">
                                    <option value="21">21√ó21</option>
                                    <option value="25" selected>25√ó25</option>
                                    <option value="29">29√ó29</option>
                                    <option value="33">33√ó33</option>
                                    <option value="37">37√ó37</option>
                                    <option value="41">41√ó41</option>
                                    <option value="45">45√ó45</option>
                                    <option value="49">49√ó49</option>
                                    <option value="53">53√ó53</option>
                                    <option value="57">57√ó57</option>
                                </select>
                                <div class="hidden" id="quietZoneContainer" style="margin-top: 8px;">
                                    <label class="small">Quiet Zone Size (pixels per side):</label>
                                    <input type="number" id="quietZone" min="0" max="100" value="16" />
                                    <div style="font-size: 11px; color: #6b7280; margin-top: 4px;">Measure the white border in your QR image</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Logo Upload -->
                    <div class="section" style="padding: 0; margin-bottom: 16px;">
                        <label>Background Logo</label>
                        <label class="file-input-label primary">
                            <span>üì§ Upload Logo</span>
                            <input type="file" id="logoUpload" accept="image/*" class="hidden" />
                        </label>
                    </div>

                    <!-- Canvas Quiet Zone -->
                    <div class="section" style="padding: 0; margin-bottom: 16px;">
                        <label>Canvas Quiet Zone: <span id="canvasQuietZoneLabel">2</span> modules</label>
                        <input type="range" id="canvasQuietZone" min="0" max="4" value="2" class="range-full" />
                        <div style="font-size: 11px; color: #6b7280; margin-top: 4px;">White border around QR on canvas (spec: 4)</div>
                    </div>

                    <!-- Logo Scale -->
                    <div class="section" style="padding: 0; margin-bottom: 16px;">
                        <label>Logo Scale: <span id="logoScaleLabel">100</span>%</label>
                        <input type="range" id="logoScale" min="10" max="120" value="100" class="range-full" />
                    </div>

                    <!-- Logo Position -->
                    <div class="section" style="padding: 0; margin-bottom: 0;">
                        <label>Logo Position</label>
                        <button id="lockBtn" class="secondary" style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                            <span id="lockIcon">üîì</span>
                            <span id="lockText">Unlocked - Drag on Canvas</span>
                        </button>
                        <div style="font-size: 11px; color: #6b7280; margin-top: 4px;">Click canvas to drag logo when unlocked</div>
                    </div>
                </div>
            </div>

            <!-- Module Size -->
            <div class="section">
                <label>Module Size: <span id="moduleSizeLabel">50</span>%</label>
                <input type="range" id="moduleSize" min="20" max="100" value="50" class="range-full" />
            </div>

            <!-- Module Shape -->
            <div class="section">
                <label>Module Shape</label>
                <select id="moduleShape" class="range-full" style="padding: 8px; border-radius: 6px; border: 1px solid #d1d5db; background: white; font-size: 14px;">
                    <option value="square">Square</option>
                    <option value="circle">Circle</option>
                    <option value="rounded">Rounded Square</option>
                    <option value="diamond">Diamond</option>
                </select>
                <div style="font-size: 11px; color: #6b7280; margin-top: 4px;">Shape only applies to data modules, not finders</div>
            </div>

            <!-- Finder Pattern -->
            <div class="section">
                <label>Finder Pattern</label>
                <select id="finderPattern" class="range-full" style="padding: 8px; border-radius: 6px; border: 1px solid #d1d5db; background: white; font-size: 14px;">
                    <option value="square">Square (Traditional)</option>
                    <option value="circle">Circle (Modern)</option>
                    <option value="hybrid">Hybrid (Circle Outer + Square Center)</option>
                    <option value="hybrid-inverse">Hybrid (Square Outer + Circle Center)</option>
                </select>
                <div style="font-size: 11px; color: #6b7280; margin-top: 4px;">Pattern for the three corner position markers</div>
            </div>

            <!-- Overlay Opacity -->
            <div class="section">
                <label>Overlay Opacity: <span id="overlayAlphaLabel">100</span>%</label>
                <input type="range" id="overlayAlpha" min="0" max="100" value="100" class="range-full" />
                <div style="font-size: 11px; color: #6b7280; margin-top: 4px;">Lower values blend QR with logo but reduce scannability</div>
            </div>



            <!-- Color Palette Editor -->
            <div class="section">
                <label style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" id="paletteToggle">
                    <span>Color Palette</span>
                    <span id="paletteArrow" style="transition: transform 0.2s;">‚ñº</span>
                </label>
                <div id="paletteEditor" style="display: none; margin-top: 12px;">
                    <div id="paletteInstructions" style="font-size: 11px; color: #6b7280; margin-bottom: 8px;">Click a color below to select it, then click modules on canvas to apply</div>

                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 12px; font-weight: 600; margin-bottom: 6px;">Dark Colors (4)</div>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px;">
                            <input type="color" id="darkPalette0" class="palette-color" data-type="dark" data-index="0" />
                            <input type="color" id="darkPalette1" class="palette-color" data-type="dark" data-index="1" />
                            <input type="color" id="darkPalette2" class="palette-color" data-type="dark" data-index="2" />
                            <input type="color" id="darkPalette3" class="palette-color" data-type="dark" data-index="3" />
                        </div>
                    </div>

                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 12px; font-weight: 600; margin-bottom: 6px;">Light Colors (4)</div>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px;">
                            <input type="color" id="lightPalette0" class="palette-color" data-type="light" data-index="0" />
                            <input type="color" id="lightPalette1" class="palette-color" data-type="light" data-index="1" />
                            <input type="color" id="lightPalette2" class="palette-color" data-type="light" data-index="2" />
                            <input type="color" id="lightPalette3" class="palette-color" data-type="light" data-index="3" />
                        </div>
                    </div>

                    <div id="contrastWarning" style="display: none; background: #fef3c7; border: 1px solid #fbbf24; padding: 8px; border-radius: 4px; font-size: 11px; color: #92400e;">
                        ‚ö†Ô∏è Low contrast detected between some colors. QR may not scan reliably.
                    </div>
                </div>
            </div>

            <!-- Background Fill -->
            <div class="section">
                <label>Background Fill</label>
                <select id="backgroundFill" class="range-full" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; background: white;">
                    <option value="transparent">Transparent</option>
                    <option value="light">Light Color</option>
                    <option value="dark">Dark Color</option>
                </select>
                <div style="font-size: 11px; color: #6b7280; margin-top: 4px;">Fill for areas without logo or when opacity &lt; 100%</div>
            </div>

            <!-- Export -->
            <button id="exportBtn" class="success">
                <span>üíæ Export PNG</span>
            </button>
        </div>

        <!-- Preview -->
        <div class="preview-area">
            <div class="preview-container">
                <!-- Canvas -->
                <canvas id="canvas" width="600" height="600" style="cursor: move;"></canvas>
            </div>
        </div>
    </div>

    <script>
        // State
        let state = {
            qrText: 'https://example.com',
            eccLevel: 'H',        // Error correction level: L, M, Q, H
            uploadedQR: null,
            generatedQR: null,
            useUploadedQR: false,
            qrSize: 25,
            quietZonePixels: 16,  // Quiet zone in source image (pixels)
            canvasQuietZone: 2,   // Quiet zone to display on canvas (modules)
            logoImage: null,
            moduleSize: 50,       // Default to 50% for dithering effect
            moduleShape: 'square', // 'square', 'circle', etc.
            finderPattern: 'square', // 'square', 'circle', etc.
            darkColor: '#000000',
            darkAlpha: 1,
            lightColor: '#ffffff',
            lightAlpha: 1,
            darkPalette: ['#000000', '#333333', '#1a1a1a', '#0d0d0d'],  // 4 dark colors
            lightPalette: ['#ffffff', '#f0f0f0', '#e0e0e0', '#d0d0d0'], // 4 light colors
            moduleColors: {},     // Per-module color overrides: {x,y} -> colorIndex
            overlayAlpha: 1,      // Overall QR overlay opacity
            backgroundFill: 'transparent',  // 'transparent', 'light', or 'dark'
            logoScale: 100,
            logoX: 50,
            logoY: 50,
            logoLocked: false
        };

        // Drag state
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        // Cached logo image for synchronous drawing during drag
        let cachedLogoImg = null;

        // Color editing state
        let editingMode = false;  // When true, clicking modules changes their color
        let selectedPaletteColor = null;  // {type: 'dark'|'light', index: 0-3}

        // Elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const qrText = document.getElementById('qrText');
        const eccLevel = document.getElementById('eccLevel');
        const generateBtn = document.getElementById('generateBtn');
        const qrUpload = document.getElementById('qrUpload');
        const qrSizeSelect = document.getElementById('qrSize');
        const quietZoneInput = document.getElementById('quietZone');
        const quietZoneContainer = document.getElementById('quietZoneContainer');
        const logoUpload = document.getElementById('logoUpload');
        const canvasQuietZoneInput = document.getElementById('canvasQuietZone');
        const moduleSize = document.getElementById('moduleSize');
        const moduleShape = document.getElementById('moduleShape');
        const finderPattern = document.getElementById('finderPattern');
        const overlayAlpha = document.getElementById('overlayAlpha');
        const backgroundFill = document.getElementById('backgroundFill');
        const logoScale = document.getElementById('logoScale');
        const lockBtn = document.getElementById('lockBtn');
        const lockIcon = document.getElementById('lockIcon');
        const lockText = document.getElementById('lockText');
        const setupToggle = document.getElementById('setupToggle');
        const setupArrow = document.getElementById('setupArrow');
        const setupPanel = document.getElementById('setupPanel');
        const paletteToggle = document.getElementById('paletteToggle');
        const paletteArrow = document.getElementById('paletteArrow');
        const paletteEditor = document.getElementById('paletteEditor');
        const contrastWarning = document.getElementById('contrastWarning');
        const exportBtn = document.getElementById('exportBtn');

        // QR Code Generation
        function generateQRCode() {
            if (!state.qrText.trim()) return;

            // Create a temporary container for QRCode.js
            const tempDiv = document.createElement('div');
            tempDiv.style.display = 'none';
            document.body.appendChild(tempDiv);

            try {
                // Generate QR code using QRCode.js
                const qr = new QRCode(tempDiv, {
                    text: state.qrText,
                    width: 200,
                    height: 200,
                    colorDark: "#000000",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel[state.eccLevel]
                });

                // Wait for the QR code to be generated
                setTimeout(() => {
                    // Check if QRCode.js exposes module count directly
                    console.log('QRCode object:', qr);
                    console.log('QRCode properties:', Object.keys(qr));
                    if (qr._oQRCode) {
                        console.log('_oQRCode:', qr._oQRCode);
                        console.log('_oQRCode properties:', Object.keys(qr._oQRCode));
                        if (qr._oQRCode.moduleCount) {
                            console.log('Module count from library:', qr._oQRCode.moduleCount);
                        }
                    }

                    const qrImage = tempDiv.querySelector('img');
                    if (qrImage) {
                        state.generatedQR = qrImage.src;
                        state.useUploadedQR = false;
                        state.moduleColors = {};  // Clear manual color overrides

                        // Check if we can get module count directly from the library
                        let moduleCountFromLib = null;
                        if (qr._oQRCode && qr._oQRCode.moduleCount) {
                            moduleCountFromLib = qr._oQRCode.moduleCount;
                        }

                        // Auto-detect the generated QR code
                        const img = new Image();
                        img.onload = () => {
                            // Use library-provided module count if available, otherwise detect
                            if (moduleCountFromLib) {
                                state.qrSize = moduleCountFromLib;
                                state.quietZonePixels = 0;  // QRCode.js doesn't add quiet zone to the image
                                console.log(`Generated: ${moduleCountFromLib}√ó${moduleCountFromLib} QR code (from library)`);
                            } else {
                                const detected = detectQRGeometry(img);
                                state.qrSize = detected.moduleCount;
                                state.quietZonePixels = detected.quietZonePixels;
                                console.log(`Generated: ${detected.moduleCount}√ó${detected.moduleCount} QR code with ${detected.quietZonePixels}px quiet zone (detected)`);
                            }

                            // Auto-adjust logo scale to fit content area
                            if (state.logoImage) {
                                const totalModules = state.qrSize + 2 * state.canvasQuietZone;
                                const contentScale = Math.round((state.qrSize / totalModules) * 100);
                                state.logoScale = contentScale;
                                logoScale.value = contentScale;
                                document.getElementById('logoScaleLabel').textContent = contentScale;
                            }

                            drawCanvas();
                        };
                        img.src = state.generatedQR;
                    }

                    // Clean up temp div
                    document.body.removeChild(tempDiv);
                }, 100);
            } catch (error) {
                console.error('QR generation error:', error);
                document.body.removeChild(tempDiv);
                alert('Failed to generate QR code. Please check your input.');
            }
        }

        function extractDominantColors(img) {
            // Create temp canvas to analyze the logo
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            tempCtx.drawImage(img, 0, 0);

            const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
            const data = imageData.data;

            // Collect dark and light colors with frequency counts
            // Quantize to reduce near-duplicates (group similar colors)
            const quantize = (val) => Math.min(255, Math.round(val / 4) * 4); // Reduce to 64 levels per channel, clamp to 255

            const darkColors = {};
            const lightColors = {};

            for (let i = 0; i < data.length; i += 16) { // Sample every 4 pixels
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];

                // Skip transparent pixels
                if (a < 128) continue;

                const luminance = 0.299 * r + 0.587 * g + 0.114 * b;

                // Quantize to reduce near-duplicates
                const qR = quantize(r);
                const qG = quantize(g);
                const qB = quantize(b);
                const colorKey = `${qR},${qG},${qB}`;

                if (luminance < 128) {
                    darkColors[colorKey] = (darkColors[colorKey] || 0) + 1;
                } else {
                    lightColors[colorKey] = (lightColors[colorKey] || 0) + 1;
                }
            }

            // Extract top colors, filtering out rare colors (anti-aliasing artifacts)
            const getTopColors = (colorFreqMap, count = 4) => {
                // Get total pixel count
                const totalPixels = Object.values(colorFreqMap).reduce((a, b) => a + b, 0);

                // Filter out colors that appear in less than 0.1% of pixels (likely anti-aliasing)
                const minFrequency = Math.max(10, totalPixels * 0.001);

                // Sort by frequency (most common first) and filter
                const sorted = Object.entries(colorFreqMap)
                    .filter(([colorKey, freq]) => freq >= minFrequency)
                    .sort((a, b) => b[1] - a[1]); // Sort by count descending

                console.log(`Filtered ${Object.keys(colorFreqMap).length - sorted.length} rare colors (anti-aliasing artifacts)`);

                // Take top N colors
                const topColors = sorted.slice(0, count);

                // Convert to hex
                return topColors.map(([colorKey, freq]) => {
                    const [r, g, b] = colorKey.split(',').map(Number);
                    return rgbToHex(r, g, b);
                });
            };

            const rgbToHex = (r, g, b) => {
                return '#' + [r, g, b].map(x => {
                    const hex = Math.round(x).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            };

            // Extract 4 most common colors from each category
            const darkPalette = getTopColors(darkColors, 4);
            const lightPalette = getTopColors(lightColors, 4);

            console.log('Dark colors found:', Object.keys(darkColors).length);
            console.log('Light colors found:', Object.keys(lightColors).length);

            // Debug: show top dark colors with their frequencies and luminance
            const darkEntries = Object.entries(darkColors).sort((a, b) => b[1] - a[1]).slice(0, 10);
            console.log('Top 10 dark colors by frequency:');
            darkEntries.forEach(([color, count]) => {
                const [r, g, b] = color.split(',').map(Number);
                const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                console.log(`  RGB(${r}, ${g}, ${b}) - Count: ${count}, Luminance: ${lum.toFixed(1)}`);
            });

            // Debug: show top light colors
            const lightEntries = Object.entries(lightColors).sort((a, b) => b[1] - a[1]).slice(0, 10);
            console.log('Top 10 light colors by frequency:');
            lightEntries.forEach(([color, count]) => {
                const [r, g, b] = color.split(',').map(Number);
                const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                console.log(`  RGB(${r}, ${g}, ${b}) - Count: ${count}, Luminance: ${lum.toFixed(1)}`);
            });

            console.log('Top 4 dark:', darkPalette);
            console.log('Top 4 light:', lightPalette);

            // Helper to get luminance from hex color (0-1 range)
            const getLuminance = (hex) => {
                const r = parseInt(hex.slice(1, 3), 16) / 255;
                const g = parseInt(hex.slice(3, 5), 16) / 255;
                const b = parseInt(hex.slice(5, 7), 16) / 255;
                return 0.299 * r + 0.587 * g + 0.114 * b;
            };

            // Validate dark palette: only use colors from logo that are dark enough
            // If no logo colors are dark enough, fall back to black
            const validateDarkPalette = (palette) => {
                // Filter to only colors that are actually dark (luminance < 0.5)
                const validColors = palette.filter(color => getLuminance(color) < 0.5);

                // If we have at least one valid dark color from logo, use only logo colors
                if (validColors.length > 0) {
                    // Pad by duplicating existing logo colors
                    while (validColors.length < 4) {
                        validColors.push(validColors[validColors.length - 1]);
                    }
                    return validColors;
                }

                // No dark colors in logo - fall back to black
                console.warn('No dark colors found in logo, using black');
                return ['#000000', '#000000', '#000000', '#000000'];
            };

            // Validate light palette: only use colors from logo that are light enough
            // If no logo colors are light enough, fall back to white
            const validateLightPalette = (palette) => {
                // Filter to only colors that are actually light (luminance > 0.5)
                const validColors = palette.filter(color => getLuminance(color) > 0.5);

                // If we have at least one valid light color from logo, use only logo colors
                if (validColors.length > 0) {
                    // Pad by duplicating existing logo colors
                    while (validColors.length < 4) {
                        validColors.push(validColors[validColors.length - 1]);
                    }
                    return validColors;
                }

                // No light colors in logo - fall back to white
                console.warn('No light colors found in logo, using white');
                return ['#ffffff', '#ffffff', '#ffffff', '#ffffff'];
            };

            const finalDarkPalette = validateDarkPalette(darkPalette);
            const finalLightPalette = validateLightPalette(lightPalette);

            // Sort dark palette: darkest to lightest (lowest luminance first)
            finalDarkPalette.sort((a, b) => getLuminance(a) - getLuminance(b));

            // Sort light palette: lightest to darkest (highest luminance first)
            finalLightPalette.sort((a, b) => getLuminance(b) - getLuminance(a));

            console.log('Dark palette luminance (darkest first):', finalDarkPalette.map(c => getLuminance(c).toFixed(2)));
            console.log('Light palette luminance (lightest first):', finalLightPalette.map(c => getLuminance(c).toFixed(2)));

            return {
                darkPalette: finalDarkPalette,
                lightPalette: finalLightPalette,
                // Keep single colors for backward compatibility
                dark: finalDarkPalette[0] || '#000000',
                light: finalLightPalette[0] || '#ffffff'
            };
        }

        // Calculate Euclidean distance between two RGB colors
        function colorDistance(c1, c2) {
            const dr = c1[0] - c2[0];
            const dg = c1[1] - c2[1];
            const db = c1[2] - c2[2];
            return Math.sqrt(dr * dr + dg * dg + db * db);
        }

        // Calculate relative luminance for contrast checking (WCAG formula)
        function getRelativeLuminance(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;

            const toLinear = (c) => c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);

            return 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
        }

        // Calculate contrast ratio between two colors
        function getContrastRatio(hex1, hex2) {
            const lum1 = getRelativeLuminance(hex1);
            const lum2 = getRelativeLuminance(hex2);
            const lighter = Math.max(lum1, lum2);
            const darker = Math.min(lum1, lum2);
            return (lighter + 0.05) / (darker + 0.05);
        }

        // Check contrast between all dark and light colors
        function checkContrast() {
            let hasLowContrast = false;
            const minContrast = 3.0; // QR codes need at least 3:1 contrast

            for (const darkColor of state.darkPalette) {
                for (const lightColor of state.lightPalette) {
                    const ratio = getContrastRatio(darkColor, lightColor);
                    if (ratio < minContrast) {
                        hasLowContrast = true;
                        break;
                    }
                }
                if (hasLowContrast) break;
            }

            contrastWarning.style.display = hasLowContrast ? 'block' : 'none';
        }

        // Convert RGB to HSL for better color matching
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }

            return [h * 360, s, l]; // h in degrees, s and l as 0-1
        }

        // Calculate hue distance (circular, 0-180)
        function hueDistance(h1, h2) {
            const diff = Math.abs(h1 - h2);
            return Math.min(diff, 360 - diff);
        }

        // Find best matching color from a palette based on a sampled RGB color
        function findBestMatch(sampledRgb, palette) {
            // Convert sampled color to HSL
            const [sampledH, sampledS, sampledL] = rgbToHsl(sampledRgb[0], sampledRgb[1], sampledRgb[2]);

            // Convert palette hex colors to RGB and HSL
            const paletteData = palette.map(hex => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                const [h, s, l] = rgbToHsl(r, g, b);
                return { hex, rgb: [r, g, b], hsl: [h, s, l] };
            });

            // Find best match using weighted distance
            let minDist = Infinity;
            let bestIndex = 0;

            for (let i = 0; i < paletteData.length; i++) {
                const [h, s, l] = paletteData[i].hsl;

                // For colors with saturation, prioritize hue matching
                // For grays (low saturation), use RGB distance
                // Use RGB if EITHER color is grayscale (hue is meaningless for achromatic colors)
                const isGrayscale = sampledS < 0.15 || s < 0.15;

                if (!isGrayscale) {
                    // Both colored: weight hue heavily, with saturation and lightness as tiebreakers
                    const hueDist = hueDistance(sampledH, h) / 180; // normalize to 0-1
                    const satDist = Math.abs(sampledS - s);
                    const lightDist = Math.abs(sampledL - l);
                    const dist = hueDist * 5 + satDist * 1 + lightDist * 1; // hue weighted 5x

                    if (dist < minDist) {
                        minDist = dist;
                        bestIndex = i;
                    }
                } else {
                    // At least one is grayscale: use simple RGB distance
                    const rgbDist = colorDistance(sampledRgb, paletteData[i].rgb);
                    if (rgbDist < minDist) {
                        minDist = rgbDist;
                        bestIndex = i;
                    }
                }
            }

            return palette[bestIndex];
        }

        function detectQRGeometry(img) {
            // Create temp canvas to analyze the image
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            tempCtx.drawImage(img, 0, 0);
            const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
            const data = imageData.data;

            // Find edges of dark content (bounding box)
            let minX = img.width, maxX = 0, minY = img.height, maxY = 0;

            for (let y = 0; y < img.height; y++) {
                for (let x = 0; x < img.width; x++) {
                    const idx = (y * img.width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const gray = 0.299 * r + 0.587 * g + 0.114 * b;

                    // Consider pixel dark if below threshold
                    if (gray < 128) {
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            // Calculate quiet zone (average of all sides)
            const quietZone = Math.round((minX + minY + (img.width - 1 - maxX) + (img.height - 1 - maxY)) / 4);

            // Content dimensions
            const contentWidth = maxX - minX + 1;
            const contentHeight = maxY - minY + 1;

            console.log('Detection Debug:', {
                imageSize: `${img.width}x${img.height}`,
                contentBox: `${minX},${minY} to ${maxX},${maxY}`,
                contentSize: `${contentWidth}x${contentHeight}`,
                quietZone: quietZone
            });

            // Try multiple detection methods and use the most reliable

            // Method 1: Count transitions in the top row (finder pattern has specific pattern)
            const topY = minY;
            let transitions = 0;
            let lastDark = false;
            for (let x = minX; x <= maxX; x++) {
                const idx = (topY * img.width + x) * 4;
                const gray = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
                const isDark = gray < 128;
                if (x > minX && isDark !== lastDark) transitions++;
                lastDark = isDark;
            }

            // Method 2: Analyze run-lengths
            const midY = Math.floor((minY + maxY) / 2);
            const runs = [];
            let currentIsDark = false;
            let runLength = 0;

            for (let x = minX; x <= maxX; x++) {
                const idx = (midY * img.width + x) * 4;
                const gray = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
                const isDark = gray < 128;

                if (x === minX) {
                    currentIsDark = isDark;
                    runLength = 1;
                } else if (isDark === currentIsDark) {
                    runLength++;
                } else {
                    runs.push(runLength);
                    currentIsDark = isDark;
                    runLength = 1;
                }
            }
            runs.push(runLength);

            console.log('Runs:', runs);

            // Method 3: Use finder pattern to calibrate (most accurate)
            // The top-left finder has a 1:1:3:1:1 ratio when scanned through its middle
            // First get a rough estimate of module size from the run analysis
            const sortedRuns = [...runs].sort((a, b) => a - b);
            const sampleSize = Math.max(2, Math.floor(sortedRuns.length * 0.3));
            const smallestRuns = sortedRuns.slice(0, sampleSize);
            const roughModuleSize = smallestRuns.reduce((a, b) => a + b, 0) / smallestRuns.length;

            console.log('Rough module size estimate:', roughModuleSize.toFixed(3));

            // Scan through the approximate middle of the top-left finder pattern
            // The finder is 7√ó7, so scan through row 3.5 (middle)
            const finderMiddleY = Math.round(minY + roughModuleSize * 3.5);
            const finderRowRuns = [];
            let finderRowDark = false;
            let finderRowLength = 0;

            for (let x = minX; x <= maxX; x++) {
                const idx = (finderMiddleY * img.width + x) * 4;
                const gray = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
                const isDark = gray < 128;

                if (x === minX) {
                    finderRowDark = isDark;
                    finderRowLength = 1;
                } else if (isDark === finderRowDark) {
                    finderRowLength++;
                } else {
                    finderRowRuns.push(finderRowLength);
                    finderRowDark = isDark;
                    finderRowLength = 1;
                }
            }
            finderRowRuns.push(finderRowLength);

            console.log('Finder middle row runs:', finderRowRuns);

            // Look for the 1:1:3:1:1 pattern in the first 5 runs
            // This should be: dark(1) - light(1) - dark(3) - light(1) - dark(1)
            let modulePixelSize = null;

            if (finderRowRuns.length >= 5 && finderRowRuns[0] > 0) {
                // First 5 runs should follow approximately 1:1:3:1:1 ratio
                const ratio1 = finderRowRuns[0];
                const ratio2 = finderRowRuns[1];
                const ratio3 = finderRowRuns[2];
                const ratio4 = finderRowRuns[3];
                const ratio5 = finderRowRuns[4];

                // Verify it looks like a finder pattern (middle should be ~3x the outer runs)
                const outerAvg = (ratio1 + ratio5) / 2;
                const middleToOuterRatio = ratio3 / outerAvg;

                console.log('Finder pattern ratios:', {
                    runs: [ratio1, ratio2, ratio3, ratio4, ratio5],
                    outerAvg,
                    middleToOuterRatio
                });

                // If the ratio is close to 3, use this for module size
                if (middleToOuterRatio > 2.5 && middleToOuterRatio < 3.5) {
                    modulePixelSize = outerAvg;  // Don't round - keep as float for accuracy
                    console.log('Finder pattern calibration: module size =', modulePixelSize.toFixed(3));
                } else {
                    console.log('Finder pattern ratio not close to 3:1, falling back');
                }
            }

            // Fallback to run analysis if finder pattern detection fails
            if (!modulePixelSize || modulePixelSize < 2) {
                modulePixelSize = roughModuleSize;
                console.log('Using rough module size:', modulePixelSize);
            }

            console.log('Final calculation:', {
                contentWidth,
                contentHeight,
                modulePixelSize,
                calculation: `${contentWidth} / ${modulePixelSize}`
            });

            // Calculate module count
            const moduleCount = Math.round(contentWidth / modulePixelSize);

            console.log('Raw module count:', moduleCount);

            // Snap to standard QR code sizes (21, 25, 29, 33, 37, 41, 45, 49, 53, 57)
            const standardSizes = [21, 25, 29, 33, 37, 41, 45, 49, 53, 57];

            // Find candidate sizes (within ¬±2 of estimated count)
            const candidates = standardSizes.filter(size => Math.abs(size - moduleCount) <= 2);

            // Validate each candidate by checking if finders exist at expected positions
            const validateSize = (size) => {
                const modSize = contentWidth / size;

                const checkFinder = (finderStartX, finderStartY) => {
                    // Finder pattern is 7√ó7 modules
                    // Scan through the middle row (module 3) to check the 1:1:3:1:1 pattern
                    const y = Math.floor(minY + modSize * (finderStartY + 3.5));
                    const samples = [];

                    for (let modX = 0; modX < 7; modX++) {
                        const x = Math.floor(minX + modSize * (finderStartX + modX + 0.5));
                        const idx = (y * img.width + x) * 4;
                        const gray = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
                        samples.push(gray < 128 ? 'D' : 'L');
                    }

                    // Expected pattern: Dark, Light, Dark, Dark, Dark, Light, Dark (DLDDDLD)
                    const pattern = samples.join('');
                    const matchesPattern = pattern === 'DLDDDLD';

                    return matchesPattern ? 1 : 0;
                };

                // Check all three finders at their starting positions
                // Finders are 7√ó7, so: top-left (0,0), top-right (size-7, 0), bottom-left (0, size-7)
                const tlScore = checkFinder(0, 0);
                const trScore = checkFinder(size - 7, 0);
                const blScore = checkFinder(0, size - 7);

                return tlScore + trScore + blScore;
            };

            // Pick the candidate with the best validation score
            let bestSize = candidates[0] || standardSizes.reduce((prev, curr) =>
                Math.abs(curr - moduleCount) < Math.abs(prev - moduleCount) ? curr : prev
            );
            let bestScore = 0;

            for (const candidate of candidates) {
                const score = validateSize(candidate);
                console.log(`Validation: ${candidate}√ó${candidate} scored ${score}/3 finders`);

                // Pick this candidate if: (1) it has a better score, OR
                // (2) it has the same score but is closer to the estimated count
                const isBetterScore = score > bestScore;
                const isSameScoreButCloser = score === bestScore &&
                    Math.abs(candidate - moduleCount) < Math.abs(bestSize - moduleCount);

                if (isBetterScore || isSameScoreButCloser) {
                    bestScore = score;
                    bestSize = candidate;
                }
            }

            // If we didn't get 3/3 finders, expand search to ¬±4 range
            if (bestScore < 3) {
                console.log('Low confidence, expanding search range...');
                const expandedCandidates = standardSizes.filter(size =>
                    Math.abs(size - moduleCount) <= 4 && !candidates.includes(size)
                );

                for (const candidate of expandedCandidates) {
                    const score = validateSize(candidate);
                    console.log(`Validation: ${candidate}√ó${candidate} scored ${score}/3 finders`);

                    const isBetterScore = score > bestScore;
                    const isSameScoreButCloser = score === bestScore &&
                        Math.abs(candidate - moduleCount) < Math.abs(bestSize - moduleCount);

                    if (isBetterScore || isSameScoreButCloser) {
                        bestScore = score;
                        bestSize = candidate;
                    }
                }
            }

            console.log('Selected size:', bestSize, 'with', bestScore, 'finder confirmations');

            // Calculate actual module size based on validated size for accuracy
            const actualModuleSize = contentWidth / bestSize;
            console.log('Actual module size for', bestSize, 'modules:', actualModuleSize.toFixed(3), 'pixels');

            return {
                moduleCount: bestSize,
                quietZonePixels: quietZone
            };
        }

        function isFinderPattern(x, y, contentModules) {
            // x, y are content module coordinates (0 to contentModules-1)
            // Finder pattern is 7x7, but include 1 module separator = 8x8 total
            const finderSize = 8;

            // Top-left finder (0-7, 0-7) - includes 7x7 finder + 1 module separator
            if (x < finderSize && y < finderSize) return true;
            // Top-right finder
            if (x >= contentModules - finderSize && y < finderSize) return true;
            // Bottom-left finder
            if (x < finderSize && y >= contentModules - finderSize) return true;

            return false;
        }


        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function drawCanvas(skipOverlay = false) {
            try {
                const canvasSize = 600;
                ctx.clearRect(0, 0, canvasSize, canvasSize);

                // Apply background fill
                if (state.backgroundFill === 'light') {
                    ctx.fillStyle = state.lightColor;
                    ctx.fillRect(0, 0, canvasSize, canvasSize);
                } else if (state.backgroundFill === 'dark') {
                    ctx.fillStyle = state.darkColor;
                    ctx.fillRect(0, 0, canvasSize, canvasSize);
                }
                // If transparent, clearRect above already handles it

                if (state.logoImage) {
                    // Calculate logo size and position
                    const scale = state.logoScale / 100;
                    const maxSize = canvasSize * scale;

                    // Calculate aspect-ratio-preserving dimensions
                    let logoWidth, logoHeight;
                    if (cachedLogoImg) {
                        const aspectRatio = cachedLogoImg.width / cachedLogoImg.height;
                        if (aspectRatio > 1) {
                            // Wider than tall
                            logoWidth = maxSize;
                            logoHeight = maxSize / aspectRatio;
                        } else {
                            // Taller than wide or square
                            logoHeight = maxSize;
                            logoWidth = maxSize * aspectRatio;
                        }
                    } else {
                        // If no cached image yet, use square as fallback
                        logoWidth = maxSize;
                        logoHeight = maxSize;
                    }

                    const logoX = (canvasSize * state.logoX / 100) - (logoWidth / 2);
                    const logoY = (canvasSize * state.logoY / 100) - (logoHeight / 2);

                    // If we have a cached image and are dragging, draw it immediately
                    if (cachedLogoImg && skipOverlay) {
                        ctx.drawImage(cachedLogoImg, logoX, logoY, logoWidth, logoHeight);
                    } else {
                        // Load the image (will update cache when loaded)
                        const img = new Image();
                        img.onload = () => {
                            try {
                                // Update cache
                                cachedLogoImg = img;

                                // Recalculate dimensions with actual image aspect ratio
                                const aspectRatio = img.width / img.height;
                                if (aspectRatio > 1) {
                                    logoWidth = maxSize;
                                    logoHeight = maxSize / aspectRatio;
                                } else {
                                    logoHeight = maxSize;
                                    logoWidth = maxSize * aspectRatio;
                                }
                                const logoX = (canvasSize * state.logoX / 100) - (logoWidth / 2);
                                const logoY = (canvasSize * state.logoY / 100) - (logoHeight / 2);

                                // Draw logo
                                ctx.drawImage(img, logoX, logoY, logoWidth, logoHeight);

                                // Only draw QR overlay if not skipping (i.e., not dragging)
                                if (!skipOverlay) {
                                    // Pass logo info to overlay so it can sample original pixels
                                    drawQROverlay(canvasSize, {
                                        image: img,
                                        x: logoX,
                                        y: logoY,
                                        width: logoWidth,
                                        height: logoHeight
                                    });
                                }
                            } catch (e) {
                                console.error('Error drawing logo:', e);
                            }
                        };
                        img.onerror = (e) => console.error('Error loading logo image:', e);
                        img.src = state.logoImage;
                    }
                } else {
                    // Only show checkerboard if background is transparent
                    if (state.backgroundFill === 'transparent') {
                        const checkSize = 20;
                        for (let y = 0; y < canvasSize; y += checkSize) {
                            for (let x = 0; x < canvasSize; x += checkSize) {
                                ctx.fillStyle = ((x / checkSize + y / checkSize) % 2 === 0) ? '#e0e0e0' : '#ffffff';
                                ctx.fillRect(x, y, checkSize, checkSize);
                            }
                        }
                    }
                    if (!skipOverlay) {
                        drawQROverlay(canvasSize);
                    }
                }
            } catch (e) {
                console.error('Error in drawCanvas:', e);
            }
        }

        function drawQROverlay(canvasSize, logoInfo = null) {
            const qrImage = state.useUploadedQR ? state.uploadedQR : state.generatedQR;
            if (!qrImage) return;

            const img = new Image();
            img.onload = () => {
                // Set overall overlay opacity
                ctx.globalAlpha = state.overlayAlpha;

                // Get the QR code dimensions (works for both uploaded and generated)
                const contentModules = state.qrSize;
                const quietZonePixels = state.quietZonePixels;
                const canvasQuietZone = state.canvasQuietZone;

                // Total modules including canvas quiet zone
                const totalModules = contentModules + 2 * canvasQuietZone;

                // Calculate content area in the source image (excluding quiet zone)
                const contentWidth = img.width - 2 * quietZonePixels;
                const contentHeight = img.height - 2 * quietZonePixels;

                // Create temp canvas to read QR code data
                const qrTempCanvas = document.createElement('canvas');
                const qrTempCtx = qrTempCanvas.getContext('2d');
                qrTempCanvas.width = img.width;
                qrTempCanvas.height = img.height;
                qrTempCtx.drawImage(img, 0, 0);
                const qrImageData = qrTempCtx.getImageData(0, 0, img.width, img.height);

                // Create temp canvas to read original logo data (not scaled canvas version)
                let logoImageData = null;
                if (logoInfo) {
                    const logoTempCanvas = document.createElement('canvas');
                    const logoTempCtx = logoTempCanvas.getContext('2d');
                    logoTempCanvas.width = logoInfo.image.width;
                    logoTempCanvas.height = logoInfo.image.height;
                    logoTempCtx.drawImage(logoInfo.image, 0, 0);
                    logoImageData = logoTempCtx.getImageData(0, 0, logoInfo.image.width, logoInfo.image.height);
                }

                // Module size on output canvas (includes quiet zone)
                const modulePixelSize = canvasSize / totalModules;

                // Helper function to draw a finder pattern
                const drawFinderPattern = (contentX, contentY, corner) => {
                    // contentX, contentY are the top-left coordinates in content space (0-based)
                    // corner: 'tl' (top-left), 'tr' (top-right), 'bl' (bottom-left)
                    // Convert to canvas coordinates (including quiet zone offset)
                    const canvasX = contentX + canvasQuietZone;
                    const canvasY = contentY + canvasQuietZone;

                    // Calculate the 8√ó8 separator area bounds
                    const separatorSize = 8;
                    const sepX1 = Math.round(canvasX * modulePixelSize);
                    const sepY1 = Math.round(canvasY * modulePixelSize);
                    const sepX2 = Math.round((canvasX + separatorSize) * modulePixelSize);
                    const sepY2 = Math.round((canvasY + separatorSize) * modulePixelSize);
                    const sepWidth = sepX2 - sepX1;
                    const sepHeight = sepY2 - sepY1;
                    const sepCenterX = sepX1 + sepWidth / 2;
                    const sepCenterY = sepY1 + sepHeight / 2;

                    if (state.finderPattern === 'circle') {
                        // Circles centered at module position 3.5, 3.5 within the 8√ó8 separator area
                        // This aligns with the center of the 7√ó7 finder pattern
                        const centerX = sepX1 + (3.5 * modulePixelSize);
                        const centerY = sepY1 + (3.5 * modulePixelSize);

                        // Draw concentric circles with radii in module units:
                        // Separator (white): 4.5 modules radius (1 module border around 7-module finder)
                        // Outer dark: 3.5 modules radius (7 modules diameter)
                        // Middle light: 2.5 modules radius (5 modules diameter)
                        // Inner dark: 1.5 modules radius (3 modules diameter)

                        // Separator white circle (radius 4.5 = 3.5 finder + 1.0 separator)
                        const separatorRadius = 4.5 * modulePixelSize;
                        ctx.fillStyle = hexToRgba(state.lightColor, state.lightAlpha);
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, separatorRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // Outer dark circle (7 modules diameter = 3.5 modules radius)
                        const outerRadius = 3.5 * modulePixelSize;
                        ctx.fillStyle = hexToRgba(state.darkColor, state.darkAlpha);
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, outerRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // Middle light ring (5 modules diameter = 2.5 modules radius)
                        const middleRadius = 2.5 * modulePixelSize;
                        ctx.fillStyle = hexToRgba(state.lightColor, state.lightAlpha);
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, middleRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // Inner dark circle (3 modules diameter = 1.5 modules radius)
                        const innerRadius = 1.5 * modulePixelSize;
                        ctx.fillStyle = hexToRgba(state.darkColor, state.darkAlpha);
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (state.finderPattern === 'hybrid') {
                        // Hybrid: circular outer rings with square center
                        const centerX = sepX1 + (3.5 * modulePixelSize);
                        const centerY = sepY1 + (3.5 * modulePixelSize);

                        // Separator white circle (radius 4.5 = 3.5 finder + 1.0 separator)
                        const separatorRadius = 4.5 * modulePixelSize;
                        ctx.fillStyle = hexToRgba(state.lightColor, state.lightAlpha);
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, separatorRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // Outer dark circle (7 modules diameter = 3.5 modules radius)
                        const outerRadius = 3.5 * modulePixelSize;
                        ctx.fillStyle = hexToRgba(state.darkColor, state.darkAlpha);
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, outerRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // Middle light ring (5 modules diameter = 2.5 modules radius)
                        const middleRadius = 2.5 * modulePixelSize;
                        ctx.fillStyle = hexToRgba(state.lightColor, state.lightAlpha);
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, middleRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // Inner dark SQUARE (3√ó3 modules, centered at 3.5, 3.5)
                        // Square extends from 2.0 to 5.0 in both dimensions
                        const squareSize = 3 * modulePixelSize;
                        const squareX = centerX - (squareSize / 2);
                        const squareY = centerY - (squareSize / 2);
                        ctx.fillStyle = hexToRgba(state.darkColor, state.darkAlpha);
                        ctx.fillRect(squareX, squareY, squareSize, squareSize);
                    } else if (state.finderPattern === 'hybrid-inverse') {
                        // Hybrid inverse: square outer rings with circular center
                        // First draw the 8√ó8 separator area (light background)
                        ctx.fillStyle = hexToRgba(state.lightColor, state.lightAlpha);
                        ctx.fillRect(sepX1, sepY1, sepWidth, sepHeight);

                        // Determine offset for 7√ó7 finder within 8√ó8 separator area
                        let xOffset = 0;
                        let yOffset = 0;
                        if (corner === 'tr') xOffset = 1;
                        if (corner === 'bl') yOffset = 1;

                        // Calculate 7√ó7 finder bounds with offset
                        const finderModules = 7;
                        const x1 = Math.round((canvasX + xOffset) * modulePixelSize);
                        const y1 = Math.round((canvasY + yOffset) * modulePixelSize);
                        const x2 = Math.round((canvasX + xOffset + finderModules) * modulePixelSize);
                        const y2 = Math.round((canvasY + yOffset + finderModules) * modulePixelSize);
                        const width = x2 - x1;
                        const height = y2 - y1;

                        // Outer 7√ó7: dark
                        ctx.fillStyle = hexToRgba(state.darkColor, state.darkAlpha);
                        ctx.fillRect(x1, y1, width, height);

                        // Inner 5√ó5: light (inset by 1 module on each side)
                        const inset1 = Math.round(modulePixelSize);
                        ctx.fillStyle = hexToRgba(state.lightColor, state.lightAlpha);
                        ctx.fillRect(x1 + inset1, y1 + inset1, width - 2 * inset1, height - 2 * inset1);

                        // Inner dark CIRCLE (3 modules diameter = 1.5 modules radius)
                        // Center the circle in the 7√ó7 square
                        const centerCircleX = x1 + width / 2;
                        const centerCircleY = y1 + height / 2;
                        const innerRadius = 1.5 * modulePixelSize;
                        ctx.fillStyle = hexToRgba(state.darkColor, state.darkAlpha);
                        ctx.beginPath();
                        ctx.arc(centerCircleX, centerCircleY, innerRadius, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Traditional square finder pattern
                        // First draw the 8√ó8 separator area (light background)
                        ctx.fillStyle = hexToRgba(state.lightColor, state.lightAlpha);
                        ctx.fillRect(sepX1, sepY1, sepWidth, sepHeight);

                        // Determine offset for 7√ó7 finder within 8√ó8 separator area
                        // Top-left: separator on right & bottom -> offset (0, 0)
                        // Top-right: separator on left & bottom -> offset (1, 0)
                        // Bottom-left: separator on right & top -> offset (0, 1)
                        let xOffset = 0;
                        let yOffset = 0;
                        if (corner === 'tr') xOffset = 1;
                        if (corner === 'bl') yOffset = 1;

                        // Calculate 7√ó7 finder bounds with offset
                        const finderModules = 7;
                        const x1 = Math.round((canvasX + xOffset) * modulePixelSize);
                        const y1 = Math.round((canvasY + yOffset) * modulePixelSize);
                        const x2 = Math.round((canvasX + xOffset + finderModules) * modulePixelSize);
                        const y2 = Math.round((canvasY + yOffset + finderModules) * modulePixelSize);
                        const width = x2 - x1;
                        const height = y2 - y1;

                        // Outer 7√ó7: dark
                        ctx.fillStyle = hexToRgba(state.darkColor, state.darkAlpha);
                        ctx.fillRect(x1, y1, width, height);

                        // Inner 5√ó5: light (inset by 1 module on each side)
                        const inset1 = Math.round(modulePixelSize);
                        ctx.fillStyle = hexToRgba(state.lightColor, state.lightAlpha);
                        ctx.fillRect(x1 + inset1, y1 + inset1, width - 2 * inset1, height - 2 * inset1);

                        // Inner 3√ó3: dark (inset by 2 modules on each side)
                        const inset2 = Math.round(modulePixelSize * 2);
                        ctx.fillStyle = hexToRgba(state.darkColor, state.darkAlpha);
                        ctx.fillRect(x1 + inset2, y1 + inset2, width - 2 * inset2, height - 2 * inset2);
                    }
                };

                // Draw the three finder patterns before drawing individual modules
                // Patterns with circular outer use centered positioning, square outer use offset positioning
                if (state.finderPattern === 'circle' || state.finderPattern === 'hybrid') {
                    // Circle/Hybrid (circular outer): 8√ó8 area positioned so circles are at standard finder positions
                    drawFinderPattern(0, 0, 'tl');
                    drawFinderPattern(contentModules - 7, 0, 'tr');
                    drawFinderPattern(0, contentModules - 7, 'bl');
                } else {
                    // Square/Hybrid-Inverse (square outer): 8√ó8 area positioned to allow separator on correct sides
                    // Top-left (0, 0): separator on right & bottom
                    // Top-right (size-8, 0): separator on left & bottom
                    // Bottom-left (0, size-8): separator on right & top
                    drawFinderPattern(0, 0, 'tl');
                    drawFinderPattern(contentModules - 8, 0, 'tr');
                    drawFinderPattern(0, contentModules - 8, 'bl');
                }

                // Draw all modules (including quiet zone)
                for (let y = 0; y < totalModules; y++) {
                    for (let x = 0; x < totalModules; x++) {
                        // Check if we're in the canvas quiet zone
                        const inQuietZone = x < canvasQuietZone || x >= contentModules + canvasQuietZone ||
                                          y < canvasQuietZone || y >= contentModules + canvasQuietZone;

                        // Convert to content coordinates (needed for color overrides later)
                        const contentX = x - canvasQuietZone;
                        const contentY = y - canvasQuietZone;

                        let isDark = false;
                        let isFinder = false;

                        if (!inQuietZone) {

                            // Sample QR code from content area only (skip quiet zone in source image)
                            const qrContentPixelX = (contentX * contentWidth) / contentModules;
                            const qrContentPixelY = (contentY * contentHeight) / contentModules;
                            const qrSampleX = Math.floor(quietZonePixels + qrContentPixelX + contentWidth / contentModules / 2);
                            const qrSampleY = Math.floor(quietZonePixels + qrContentPixelY + contentHeight / contentModules / 2);
                            const qrClampedX = Math.min(qrSampleX, img.width - 1);
                            const qrClampedY = Math.min(qrSampleY, img.height - 1);
                            const qrPixelIndex = (qrClampedY * img.width + qrClampedX) * 4;
                            isDark = qrImageData.data[qrPixelIndex] < 128;

                            // Determine if this is a finder pattern (in content coordinates)
                            isFinder = isFinderPattern(contentX, contentY, contentModules);
                        }

                        const currentModuleSize = isFinder ? 1 : state.moduleSize / 100;

                        // Use pixel-aligned boundaries to avoid gaps
                        const moduleX1 = Math.round(x * modulePixelSize);
                        const moduleY1 = Math.round(y * modulePixelSize);
                        const moduleX2 = Math.round((x + 1) * modulePixelSize);
                        const moduleY2 = Math.round((y + 1) * modulePixelSize);
                        const actualModuleWidth = moduleX2 - moduleX1;
                        const actualModuleHeight = moduleY2 - moduleY1;

                        // Quiet zone modules are always light colored (full size)
                        if (inQuietZone) {
                            ctx.fillStyle = hexToRgba(state.lightColor, state.lightAlpha);
                            ctx.fillRect(moduleX1, moduleY1, actualModuleWidth, actualModuleHeight);
                            continue;
                        }

                        // Determine color for this module
                        let moduleColor;

                        // Check for manual color override first
                        const overrideKey = `${contentX},${contentY}`;
                        const colorOverride = state.moduleColors[overrideKey];

                        if (colorOverride) {
                            // Use manually assigned color
                            const palette = colorOverride.type === 'dark' ? state.darkPalette : state.lightPalette;
                            moduleColor = palette[colorOverride.index];
                        } else if (isFinder) {
                            // Finders use single color for reliability
                            moduleColor = isDark ? state.darkColor : state.lightColor;
                        } else if (logoImageData && logoInfo) {
                            // Sample from ORIGINAL logo image at module center
                            const moduleCenterX = moduleX1 + actualModuleWidth / 2;
                            const moduleCenterY = moduleY1 + actualModuleHeight / 2;

                            // Map canvas position to original logo position
                            const logoLocalX = moduleCenterX - logoInfo.x;
                            const logoLocalY = moduleCenterY - logoInfo.y;

                            // Convert from scaled logo coordinates to original image coordinates
                            const logoOriginalX = Math.floor((logoLocalX / logoInfo.width) * logoInfo.image.width);
                            const logoOriginalY = Math.floor((logoLocalY / logoInfo.height) * logoInfo.image.height);

                            // Clamp to logo bounds
                            const clampedX = Math.max(0, Math.min(logoInfo.image.width - 1, logoOriginalX));
                            const clampedY = Math.max(0, Math.min(logoInfo.image.height - 1, logoOriginalY));

                            const logoPixelIndex = (clampedY * logoInfo.image.width + clampedX) * 4;

                            const sampledR = logoImageData.data[logoPixelIndex];
                            const sampledG = logoImageData.data[logoPixelIndex + 1];
                            const sampledB = logoImageData.data[logoPixelIndex + 2];

                            // Find best matching color from appropriate palette
                            const palette = isDark ? state.darkPalette : state.lightPalette;
                            moduleColor = findBestMatch([sampledR, sampledG, sampledB], palette);
                        } else {
                            // No logo - use default colors
                            moduleColor = isDark ? state.darkColor : state.lightColor;
                        }

                        // Skip finder modules - they're already drawn
                        if (isFinder) {
                            continue;
                        }

                        const alpha = isDark ? state.darkAlpha : state.lightAlpha;
                        ctx.fillStyle = hexToRgba(moduleColor, alpha);

                        // Data modules: apply size and shape
                        const shrunkWidth = actualModuleWidth * currentModuleSize;
                        const shrunkHeight = actualModuleHeight * currentModuleSize;
                        const offsetX = (actualModuleWidth - shrunkWidth) / 2;
                        const offsetY = (actualModuleHeight - shrunkHeight) / 2;
                        const centerX = moduleX1 + offsetX + shrunkWidth / 2;
                        const centerY = moduleY1 + offsetY + shrunkHeight / 2;

                        // Draw shape based on state.moduleShape
                        if (state.moduleShape === 'circle') {
                            // Draw circle
                            const radius = Math.min(shrunkWidth, shrunkHeight) / 2;
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (state.moduleShape === 'rounded') {
                            // Draw rounded square
                            const x = moduleX1 + offsetX;
                            const y = moduleY1 + offsetY;
                            const radius = Math.min(shrunkWidth, shrunkHeight) * 0.25; // 25% radius
                            ctx.beginPath();
                            ctx.roundRect(x, y, shrunkWidth, shrunkHeight, radius);
                            ctx.fill();
                        } else if (state.moduleShape === 'diamond') {
                            // Draw diamond (45¬∞ rotated square)
                            ctx.save();
                            ctx.translate(centerX, centerY);
                            ctx.rotate(Math.PI / 4); // 45 degrees
                            const halfSize = Math.min(shrunkWidth, shrunkHeight) / 2;
                            ctx.fillRect(-halfSize, -halfSize, halfSize * 2, halfSize * 2);
                            ctx.restore();
                        } else {
                            // Default: square
                            ctx.fillRect(moduleX1 + offsetX, moduleY1 + offsetY, shrunkWidth, shrunkHeight);
                        }
                    }
                }

                // Reset global alpha
                ctx.globalAlpha = 1.0;
            };
            img.src = qrImage;
        }

        // Event Listeners
        generateBtn.addEventListener('click', generateQRCode);

        qrUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        if (img.width === img.height) {
                            state.uploadedQR = event.target.result;
                            state.useUploadedQR = true;
                            state.moduleColors = {};  // Clear manual color overrides

                            // Auto-detect QR geometry
                            const detected = detectQRGeometry(img);
                            state.qrSize = detected.moduleCount;
                            state.quietZonePixels = detected.quietZonePixels;

                            // Update UI
                            qrSizeSelect.value = detected.moduleCount;
                            quietZoneInput.value = detected.quietZonePixels;
                            qrSizeSelect.classList.remove('hidden');
                            quietZoneContainer.classList.remove('hidden');

                            console.log(`Detected: ${detected.moduleCount}√ó${detected.moduleCount} QR code with ${detected.quietZonePixels}px quiet zone`);

                            // Auto-adjust logo scale to fit content area
                            if (state.logoImage) {
                                const totalModules = state.qrSize + 2 * state.canvasQuietZone;
                                const contentScale = Math.round((state.qrSize / totalModules) * 100);
                                state.logoScale = contentScale;
                                logoScale.value = contentScale;
                                document.getElementById('logoScaleLabel').textContent = contentScale;
                            }

                            drawCanvas();
                        } else {
                            alert('QR code image must be square');
                        }
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        qrSizeSelect.addEventListener('change', (e) => {
            state.qrSize = parseInt(e.target.value);

            // Auto-adjust logo scale to fit content area when QR size changes
            if (state.logoImage) {
                const totalModules = state.qrSize + 2 * state.canvasQuietZone;
                const contentScale = Math.round((state.qrSize / totalModules) * 100);
                state.logoScale = contentScale;
                logoScale.value = contentScale;
                document.getElementById('logoScaleLabel').textContent = contentScale;
            }

            drawCanvas();
        });

        quietZoneInput.addEventListener('input', (e) => {
            state.quietZonePixels = parseInt(e.target.value);
            drawCanvas();
        });

        canvasQuietZoneInput.addEventListener('input', (e) => {
            state.canvasQuietZone = parseInt(e.target.value);
            document.getElementById('canvasQuietZoneLabel').textContent = state.canvasQuietZone;

            // Auto-adjust logo scale to fit content area when quiet zone changes
            if (state.logoImage) {
                const totalModules = state.qrSize + 2 * state.canvasQuietZone;
                const contentScale = Math.round((state.qrSize / totalModules) * 100);
                state.logoScale = contentScale;
                logoScale.value = contentScale;
                document.getElementById('logoScaleLabel').textContent = contentScale;
            }

            drawCanvas();
        });

        logoUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    state.logoImage = event.target.result;
                    cachedLogoImg = null; // Clear cache when new logo is uploaded

                    // Extract dominant colors from logo
                    const img = new Image();
                    img.onload = () => {
                        const colors = extractDominantColors(img);
                        state.darkColor = colors.dark;
                        state.lightColor = colors.light;
                        state.darkPalette = colors.darkPalette;
                        state.lightPalette = colors.lightPalette;
                        console.log(`Extracted colors - Dark: ${colors.dark}, Light: ${colors.light}`);
                        console.log(`Dark palette:`, colors.darkPalette);
                        console.log(`Light palette:`, colors.lightPalette);

                        // Update palette UI
                        updatePaletteUI();

                        // Calculate logo scale to fit content area only (exclude canvas quiet zone)
                        const totalModules = state.qrSize + 2 * state.canvasQuietZone;
                        const contentScale = Math.round((state.qrSize / totalModules) * 100);
                        state.logoScale = contentScale;
                        logoScale.value = contentScale;
                        document.getElementById('logoScaleLabel').textContent = contentScale;
                        console.log(`Logo scaled to ${contentScale}% to fit content area`);

                        drawCanvas();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        moduleSize.addEventListener('input', (e) => {
            state.moduleSize = parseInt(e.target.value);
            document.getElementById('moduleSizeLabel').textContent = state.moduleSize;
            drawCanvas();
        });

        moduleShape.addEventListener('change', (e) => {
            state.moduleShape = e.target.value;
            drawCanvas();
        });

        finderPattern.addEventListener('change', (e) => {
            state.finderPattern = e.target.value;
            drawCanvas();
        });

        overlayAlpha.addEventListener('input', (e) => {
            state.overlayAlpha = parseInt(e.target.value) / 100;
            document.getElementById('overlayAlphaLabel').textContent = e.target.value;
            drawCanvas();
        });

        backgroundFill.addEventListener('change', (e) => {
            state.backgroundFill = e.target.value;
            drawCanvas();
        });


        logoScale.addEventListener('input', (e) => {
            state.logoScale = parseInt(e.target.value);
            document.getElementById('logoScaleLabel').textContent = state.logoScale;
            drawCanvas();
        });

        // Lock button toggle
        lockBtn.addEventListener('click', () => {
            state.logoLocked = !state.logoLocked;
            if (state.logoLocked) {
                lockIcon.textContent = 'üîí';
                lockText.textContent = 'Locked - Color Edit Mode';
                canvas.style.cursor = editingMode ? 'crosshair' : 'default';
            } else {
                lockIcon.textContent = 'üîì';
                lockText.textContent = 'Unlocked - Drag on Canvas';
                canvas.style.cursor = state.logoImage ? 'move' : 'default';
            }
        });

        // Setup panel toggle
        setupToggle.addEventListener('click', () => {
            const isHidden = setupPanel.style.display === 'none';
            setupPanel.style.display = isHidden ? 'block' : 'none';
            setupArrow.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
        });

        // Palette toggle
        paletteToggle.addEventListener('click', () => {
            const isHidden = paletteEditor.style.display === 'none';
            paletteEditor.style.display = isHidden ? 'block' : 'none';
            paletteArrow.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
        });

        // Function to update palette UI from state
        function updatePaletteUI() {
            for (let i = 0; i < 4; i++) {
                document.getElementById(`darkPalette${i}`).value = state.darkPalette[i];
                document.getElementById(`lightPalette${i}`).value = state.lightPalette[i];
            }
            checkContrast();
        }

        // Palette color change and selection handlers
        document.querySelectorAll('.palette-color').forEach(input => {
            // Handle color value changes
            input.addEventListener('input', (e) => {
                const type = e.target.dataset.type;
                const index = parseInt(e.target.dataset.index);
                const newColor = e.target.value;

                if (type === 'dark') {
                    state.darkPalette[index] = newColor;
                    // Update main dark color if this is the first one
                    if (index === 0) {
                        state.darkColor = newColor;
                    }
                } else {
                    state.lightPalette[index] = newColor;
                    // Update main light color if this is the first one
                    if (index === 0) {
                        state.lightColor = newColor;
                    }
                }

                checkContrast();
                drawCanvas();
            });

            // Handle palette color selection for module editing
            input.addEventListener('click', (e) => {
                const type = e.target.dataset.type;
                const index = parseInt(e.target.dataset.index);

                // Toggle selection
                if (selectedPaletteColor &&
                    selectedPaletteColor.type === type &&
                    selectedPaletteColor.index === index) {
                    // Deselect
                    selectedPaletteColor = null;
                    editingMode = false;
                    document.querySelectorAll('.palette-color').forEach(el => el.classList.remove('selected'));
                    document.getElementById('paletteInstructions').textContent =
                        'Click a color below to select it, then click modules on canvas to apply';
                } else {
                    // Select this color
                    selectedPaletteColor = { type, index };
                    editingMode = true;
                    document.querySelectorAll('.palette-color').forEach(el => el.classList.remove('selected'));
                    e.target.classList.add('selected');
                    document.getElementById('paletteInstructions').textContent =
                        `‚úì ${type.charAt(0).toUpperCase() + type.slice(1)} color ${index + 1} selected - Click modules to apply`;
                    canvas.style.cursor = 'crosshair';
                }
            });
        });

        // Canvas drag handlers
        canvas.addEventListener('mousedown', (e) => {
            // If logo is unlocked, allow dragging (no color editing)
            if (!state.logoLocked && state.logoImage) {
                isDragging = true;
                const rect = canvas.getBoundingClientRect();
                dragStartX = e.clientX - rect.left;
                dragStartY = e.clientY - rect.top;
                canvas.style.cursor = 'grabbing';
                return;
            }

            // If logo is locked and in editing mode, apply selected color to module
            if (state.logoLocked && editingMode && selectedPaletteColor) {
                const rect = canvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                const canvasSize = 600;

                // Calculate which module was clicked
                const contentModules = state.qrSize;
                const canvasQuietZone = state.canvasQuietZone;
                const totalModules = contentModules + 2 * canvasQuietZone;
                const modulePixelSize = canvasSize / totalModules;

                const moduleX = Math.floor(canvasX / modulePixelSize);
                const moduleY = Math.floor(canvasY / modulePixelSize);

                // Check if click is within content area (not quiet zone)
                const inQuietZone = moduleX < canvasQuietZone || moduleX >= contentModules + canvasQuietZone ||
                                    moduleY < canvasQuietZone || moduleY >= contentModules + canvasQuietZone;

                if (!inQuietZone) {
                    // Convert to content coordinates
                    const contentX = moduleX - canvasQuietZone;
                    const contentY = moduleY - canvasQuietZone;

                    // Check if it's a finder pattern (can't edit finders)
                    const isFinder = isFinderPattern(contentX, contentY, contentModules);

                    if (!isFinder) {
                        // Store the color override
                        const key = `${contentX},${contentY}`;
                        state.moduleColors[key] = {
                            type: selectedPaletteColor.type,
                            index: selectedPaletteColor.index
                        };

                        console.log(`Module (${contentX},${contentY}) set to ${selectedPaletteColor.type}[${selectedPaletteColor.index}]`);
                        drawCanvas();
                    }
                }
                return;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Calculate new position as percentage
            state.logoX = Math.max(0, Math.min(100, (mouseX / canvas.width) * 100));
            state.logoY = Math.max(0, Math.min(100, (mouseY / canvas.height) * 100));

            // Skip overlay drawing while dragging for better performance
            drawCanvas(true);
        });

        canvas.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = state.logoLocked ? 'default' : 'move';
                // Redraw with full overlay after drag ends
                drawCanvas();
            }
        });

        canvas.addEventListener('mouseleave', () => {
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = state.logoLocked ? 'default' : 'move';
                // Redraw with full overlay after drag ends
                drawCanvas();
            }
        });

        qrText.addEventListener('input', (e) => {
            state.qrText = e.target.value;
        });

        eccLevel.addEventListener('change', (e) => {
            state.eccLevel = e.target.value;
        });

        exportBtn.addEventListener('click', () => {
            try {
                canvas.toBlob((blob) => {
                    if (blob) {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.download = 'custom-qr-code.png';
                        link.href = url;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                    }
                }, 'image/png');
            } catch (error) {
                console.error('Export error:', error);
                const link = document.createElement('a');
                link.download = 'custom-qr-code.png';
                link.href = canvas.toDataURL('image/png');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        });

        // Initial setup
        updatePaletteUI();
        drawCanvas();
    </script>
</body>
</html>